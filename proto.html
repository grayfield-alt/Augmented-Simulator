<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Parry Roguelike Prototype</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #eee;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', system-ui, sans-serif;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        canvas {
            background-color: #222;
            border: 2px solid #444;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 800px;
            height: 500px;
            pointer-events: none;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0) 50%, rgba(255, 0, 0, 0.4) 100%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .vignette.active {
            opacity: 1;
        }

        #top-status {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 20px;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .status-box {
            color: #fff;
        }

        .hp-text {
            color: #ff5e5e;
        }

        .atk-text {
            color: #ffbf00;
        }

        .def-text {
            color: #4db8ff;
        }

        #bottom-ui {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .cost-info {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);
            font-size: 24px;
            font-weight: bold;
        }

        #augment-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        .augment-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .augment-card {
            width: 200px;
            height: 280px;
            padding: 20px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background: #222;
        }

        .augment-card:hover {
            transform: translateY(-10px);
        }

        .tier-common {
            border: 3px solid #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.3);
        }

        .tier-epic {
            border: 3px solid #a855f7;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.3);
        }

        .tier-unique {
            border: 3px solid #facc15;
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.3);
        }

        .tier-common h3 {
            color: #4ade80;
        }

        .tier-epic h3 {
            color: #a855f7;
        }

        .tier-unique h3 {
            color: #facc15;
        }

        #guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: #fff;
            padding: 40px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .guide-content {
            max-width: 600px;
            width: 100%;
            line-height: 1.6;
        }

        .guide-content h2 {
            color: #facc15;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .guide-content h3 {
            color: #4ade80;
            margin-top: 20px;
        }

        .guide-content ul {
            padding-left: 20px;
        }

        .guide-content li {
            margin-bottom: 8px;
        }

        .guide-close-btn {
            margin-top: 30px;
            background: #555;
            color: #fff;
        }

        .guide-btn {
            background: #222;
            color: #ccc;
            border: 1px solid #444;
            margin-top: 15px;
        }

        .guide-btn:hover {
            background: #333;
            color: #fff;
            border-color: #666;
        }

        #event-overlay,
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        #game-over-overlay {
            background: rgba(50, 0, 0, 0.9);
            z-index: 300;
        }

        .retry-btn {
            background: #ff4a4a;
            color: #fff;
            padding: 15px 30px;
            font-size: 20px;
            margin-top: 20px;
        }

        .event-container {
            display: flex;
            gap: 20px;
        }

        .event-card {
            width: 220px;
            padding: 30px;
            background: #333;
            border: 2px solid #555;
            border-radius: 12px;
            color: #fff;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .event-card:hover {
            border-color: #fff;
            transform: translateY(-5px);
        }

        .reroll-btn {
            background: #555;
            color: #fff;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 14px;
        }

        .reroll-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .actions {
            display: flex;
            gap: 10px;
        }

        #hit-icons-container {
            position: absolute;
            bottom: 120px;
            /* ë²„íŠ¼ ìœ„ìª½ */
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .hit-icon {
            width: 15px;
            height: 15px;
            background: #4ade80;
            /* GREEN */
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s;
        }

        .hit-icon.used {
            opacity: 0.2;
            background: #222;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            background: #444 !important;
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-atk {
            background: #4a9eff;
            color: white;
        }

        button.action-atk {
            border-bottom: 3px solid #ff4a4a;
        }

        button.action-exc {
            border-bottom: 3px solid #00ffcc;
        }

        button.action-str {
            border-bottom: 3px solid #ffd700;
        }

        #msg-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #message {
            font-size: 48px;
            font-weight: 900;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #turn-indicator {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="start-overlay">
            <h1 style="color:#fff; margin-bottom: 30px;">RPG BATTLE PROTOTYPE</h1>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="start-btn" onclick="startGame()">âš”ï¸ ê²Œì„ ì‹œì‘</button>
                <button class="guide-btn" onclick="toggleGuide(true)">â“ ê°€ì´ë“œ</button>
            </div>
        </div>
        <div id="guide-overlay">
            <div class="guide-content">
                <h2>ğŸ® ê²Œì„ ê°€ì´ë“œ</h2>

                <h3>1. ë°©ì–´ (ì ì˜ í„´)</h3>
                <ul>
                    <li>ì ì˜ ê³µê²©ì´ ë“¤ì–´ì˜¬ ë•Œ **í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ í´ë¦­**í•˜ì—¬ íŒ¨ë§ì„ ì‹œë„í•˜ì„¸ìš”.</li>
                    <li>**PERFECT**: ì ì¤‘ ì§ì „ ë°©ì–´ (AP +2 ìˆ˜ê¸‰)</li>
                    <li>**GOOD**: ì¡°ê¸ˆ ë¹ ë¥¸ ë°©ì–´ (AP +1 ìˆ˜ê¸‰)</li>
                </ul>

                <h3>2. ê³µê²© (í”Œë ˆì´ì–´ í„´)</h3>
                <ul>
                    <li>**ê³µê²© (2 AP)**: ë‹¨ì¼ ì  ê³µê²©. ìŠ¤í‚¬ ì„ íƒ í›„ ëŒ€ìƒì„ í´ë¦­í•˜ì„¸ìš”.</li>
                    <li>**íšŒì „ ë² ê¸° (3 AP)**: ëª¨ë“  ì  ê³µê²©. ì¦‰ì‹œ ë°œë™ë©ë‹ˆë‹¤.</li>
                    <li>**ê°•íƒ€ (5 AP)**: ë†’ì€ í”¼í•´ì˜ ê°•ê³µê²©. ìŠ¤í‚¬ ì„ íƒ í›„ ëŒ€ìƒì„ í´ë¦­í•˜ì„¸ìš”.</li>
                    <li>ê° ìŠ¤í‚¬ì€ í•œ í„´ì— **ìµœëŒ€ 1íšŒ**ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>

                <h3>3. ì¦ê°• ë° ì´ë²¤íŠ¸</h3>
                <ul>
                    <li>ë¼ìš´ë“œë¥¼ í´ë¦¬ì–´í•  ë•Œë§ˆë‹¤ ê°•ë ¥í•œ **ì¦ê°•(Augment)**ì„ ê³¨ë¼ ë¹Œë“œë¥¼ ì™„ì„±í•˜ì„¸ìš”.</li>
                    <li>3ë¼ìš´ë“œëŠ” ê°•ë ¥í•œ ë³´ë„ˆìŠ¤ë‚˜ íšŒë³µì„ ì–»ëŠ” **ì´ë²¤íŠ¸ ë¼ìš´ë“œ**ì…ë‹ˆë‹¤.</li>
                </ul>

                <h3>4. ì  ê³µê²© ì •ë³´</h3>
                <ul>
                    <li>í™”ë©´ ìš°í•˜ë‹¨ì˜ **ì´ˆë¡ìƒ‰ ì•„ì´ì½˜**ì€ í˜„ì¬ ê³µê²©í•˜ëŠ” ì ì˜ ë‚¨ì€ ì—°íƒ€ íšŸìˆ˜ì…ë‹ˆë‹¤.</li>
                    <li>ì ì—ê²Œ í•œ ëŒ€ ë§ê±°ë‚˜ ë°©ì–´í•  ë•Œë§ˆë‹¤ í•˜ë‚˜ì”© ì–´ë‘ì›Œì§€ë‹ˆ ë°•ìë¥¼ ë†“ì¹˜ì§€ ë§ˆì„¸ìš”!</li>
                    <li>**Boss Round**ì˜ ìµœì¢… ë³´ìŠ¤ëŠ” ë¬´ë ¤ 3ê°€ì§€ íŒ¨í„´ì„ ì„ì–´ì„œ ì‚¬ìš©í•˜ë‹ˆ ì£¼ì˜í•˜ì„¸ìš”!</li>
                </ul>
            </div>
            <button class="guide-close-btn" onclick="toggleGuide(false)">ë‹«ê¸°</button>
        </div>
        <div id="augment-overlay">
            <h2 style="color:#fff; margin-bottom: 20px;">Choose an Augment</h2>
            <div id="augment-cards" class="augment-container"></div>
            <button id="btn-reroll" class="reroll-btn" onclick="rerollAugments()">Reroll (1 Remaining)</button>
        </div>
        <div id="event-overlay">
            <h2 style="color:#fff; margin-bottom: 30px;">Round 3: Event Option</h2>
            <div class="event-container">
                <div class="event-card" onclick="selectEventOption(1)">
                    <h3>ğŸ ì„ ë¬¼</h3>
                    <p>Common ì¦ê°• 1ê°œ ì„ íƒ</p>
                </div>
                <div class="event-card" onclick="selectEventOption(2)">
                    <h3>ğŸ• íœ´ì‹</h3>
                    <p>HP íšŒë³µ 35%</p>
                </div>
            </div>
        </div>
        <div id="game-over-overlay">
            <h1 style="color:#ff4a4a; font-size: 64px; margin-bottom: 20px;">GAME OVER</h1>
            <p style="color:#ccc; margin-bottom: 20px;">ì „ì‚¬í•˜ì…¨ìŠµë‹ˆë‹¤...</p>
            <button class="retry-btn" onclick="retryGame()">ğŸ”„ Retry?</button>
        </div>
        <div id="ui-layer">
            <div id="vignette" class="vignette"></div>
            <div id="top-status">
                <div class="status-box">HP: <span id="p-hp" class="hp-text">100</span></div>
                <div class="status-box">ATK: <span id="p-atk" class="atk-text">50</span></div>
                <div class="status-box">DEF: <span id="p-def" class="def-text">0</span></div>
            </div>
            <div id="turn-indicator">Monster's Turn</div>
            <div id="msg-container">
                <div id="message">PERFECT!</div>
            </div>
            <div id="hit-icons-container"></div>
            <div id="bottom-ui">
                <div class="cost-info">
                    <span class="ap-text">AP: <span id="p-ap">0</span></span>
                </div>
                <div class="actions">
                    <button id="btn-atk" class="action-atk" disabled>1. ê³µê²© (2 AP)</button>
                    <button id="btn-spin" class="action-spin" style="background: #4a4;" disabled>2. íšŒì „ ë² ê¸° (3
                        AP)</button>
                    <button id="btn-heavy" class="action-heavy" style="background: #a84;" disabled>3. ê°•íƒ€ (5 AP)</button>
                    <button id="btn-end" style="background: #a33;" disabled>í„´ ì¢…ë£Œ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const AUGMENT_DATA = {
            "Common": [
                { id: "c1", name: "ë‚ ì¹´ë¡œì›€", desc: "ê³µê²©ë ¥ Ã—1.10", effect: p => p.augBuffs.atk *= 1.1 },
                { id: "c2", name: "ì¶•ì ëœ ë¶„ë…¸", desc: "ê°•íƒ€ ê³µê²©ë ¥ Ã—1.20", effect: p => p.augBuffs.heavy *= 1.2 },
                { id: "c3", name: "íšŒì „ ê°€ì†", desc: "íšŒì „ë² ê¸° ê³µê²©ë ¥ Ã—1.15", effect: p => p.augBuffs.spin *= 1.15 },
                { id: "c4", name: "ì •ë°€ ë°©ì–´", desc: "íŒ¨ë§ ì„±ê³µ ì‹œ AP +1 (í„´ë‹¹ 1íšŒ)", effect: p => p.augBuffs.parryAp += 1 },
                { id: "c5", name: "ì—°ì† í˜¸í¡", desc: "ì „íˆ¬ ì‹œì‘ ì‹œ AP +2", effect: p => p.augBuffs.startAp += 2 },
                { id: "c6", name: "ì²˜í˜• ë³¸ëŠ¥", desc: "ëŒ€ìƒ HP 30% ì´í•˜ì¼ ë•Œ ê³µê²©ë ¥ Ã—1.15", effect: p => p.augBuffs.executeLow = 0.3 },
                { id: "c7", name: "ì•½ì  íŒŒì•…", desc: "ê°™ì€ ì  ì—°ì† ê³µê²© ì‹œ 2íƒ€ë¶€í„° ê³µê²©ë ¥ Ã—1.10", effect: p => p.augBuffs.stackAtk = 0.1 },
                { id: "c8", name: "ì² ê°‘ ë¶„ì‡„", desc: "ê°•íƒ€ ì ì¤‘ ì‹œ ë‹¤ìŒ í„´ ì²« ê³µê²© ê³µê²©ë ¥ Ã—1.15", effect: p => p.augBuffs.heavySunder = 0.15 },
                { id: "c9", name: "í”¼ì˜ íšŒìˆ˜", desc: "ì  ì²˜ì¹˜ ì‹œ AP +1 (í„´ë‹¹ 2íšŒ)", effect: p => p.augBuffs.killAp += 1 },
                { id: "c10", name: "ì§‘ì¤‘ë ¥", desc: "í¼í™íŠ¸ íŒ¨ë§ ì„±ê³µ ì‹œ ë‹¤ìŒ ê³µê²©ë ¥ Ã—1.20", effect: p => p.augBuffs.perfectFocus = 0.20 }
            ],
            "Epic": [
                { id: "e1", name: "ì•½ì  í•´ë¶€", desc: "ê°™ì€ ì  ì—°ì† ê³µê²© ì‹œ ê³µê²©ë ¥ Ã—1.06 (ìµœëŒ€ 5ì¤‘ì²©)", effect: p => p.augBuffs.stackAtkEpic = 0.06 },
                { id: "e2", name: "ê³¼ì—´ íƒ€ê²©", desc: "ê°•íƒ€ ì‚¬ìš© í›„ ë‹¤ìŒ í„´ ì²« ê³µê²© ê³µê²©ë ¥ Ã—1.35", effect: p => p.augBuffs.heavyOverheat = 0.35 },
                { id: "e3", name: "ì›ì‹¬ í­ë°œ", desc: "íšŒì „ë² ê¸° ê³µê²©ë ¥ Ã—1.25 / ì²˜ì¹˜ ì‹œ AP +1", effect: p => { p.augBuffs.spin *= 1.25; p.augBuffs.spinKillAp += 1; } },
                { id: "e4", name: "ì™„ë²½í•œ ë¦¬ë“¬", desc: "í¼í™íŠ¸ íŒ¨ë§ ì‹œ ì´ë²ˆ í„´ ê³µê²©ë ¥ Ã—1.20", effect: p => p.augBuffs.turnAtkPerf = 0.2 },
                { id: "e5", name: "ì´ˆë°˜ ê°€ì†", desc: "ì „íˆ¬ ì‹œì‘ ì‹œ AP +3 / ì²« í„´ ê³µê²©ë ¥ Ã—1.10", effect: p => { p.augBuffs.startAp += 3; p.augBuffs.startTurnAtk = 0.1; } },
                { id: "e6", name: "í”¼ì˜ ìˆ˜í™•", desc: "ì  ì²˜ì¹˜ ì‹œ ê³µê²©ë ¥ Ã—1.04 (ìµœëŒ€ 10ì¤‘ì²©)", effect: p => p.augBuffs.killStackAtk = 0.04 },
                { id: "e7", name: "ë‹¨ë‘ì˜ ê°", desc: "ì  HP 30% ì´í•˜ì¼ ë•Œ ê°•íƒ€ ê³µê²©ë ¥ Ã—1.40", effect: p => p.augBuffs.heavyExecute = 0.4 },
                { id: "e8", name: "ì¹¨ì°©í•œ í­ë ¥", desc: "í˜„ì¬ AP ê°€ 0~2ì¼ ë•Œ ê³µê²©ë ¥ Ã—1.18", effect: p => p.augBuffs.lowApAtk = 1.18 },
                { id: "e9", name: "ê´€ì„± ë² ê¸°", desc: "ê¸°ë³¸ ê³µê²© ì‚¬ìš© ì‹œ ë‹¤ìŒ í„´ ì²« ê³µê²© ê³µê²©ë ¥ Ã—1.15", effect: p => p.augBuffs.inertiaSlice = 0.15 },
                { id: "e10", name: "íŒŒê´´ì˜ ë§¥ë°•", desc: "ë§¤ í„´ ì²« ê³µê²© ê³µê²©ë ¥ Ã—1.15 (ê°•íƒ€ë¼ë©´ x1.25)", effect: p => p.augBuffs.firstAtkMult = 0.15 }
            ],
            "Unique": [
                { id: "u1", name: "ê²€ì„±ì˜ ì„œì•½", desc: "ëª¨ë“  ìŠ¤í‚¬ ê³µê²©ë ¥ Ã—1.20", effect: p => { p.augBuffs.atk *= 1.2; p.augBuffs.spin *= 1.2; p.augBuffs.heavy *= 1.2; } },
                { id: "u2", name: "í° í•œ ë°©", desc: "ê°•íƒ€ ê³µê²©ë ¥ Ã—1.60 / ê°•íƒ€ ì²˜ì¹˜ ì‹œ AP +2", effect: p => { p.augBuffs.heavy *= 1.6; p.augBuffs.heavyKillAp += 2; } },
                { id: "u3", name: "í­í’ì˜ ì¤‘ì‹¬", desc: "íšŒì „ë² ê¸° ê³µê²©ë ¥ Ã—1.50 / ì  2ë§ˆë¦¬ ì´ìƒ ì‹œ ì¶”ê°€ x1.1", effect: p => { p.augBuffs.spin *= 1.5; p.augBuffs.spinMultiTarget = 0.1; } },
                { id: "u4", name: "ë¬´í•œ í…œí¬", desc: "ì „íˆ¬ ì‹œì‘ AP +4 / í¼í™íŠ¸ íŒ¨ë§ ì‹œ AP +1 (í„´ë‹¹ 2)", effect: p => { p.augBuffs.startAp += 4; p.augBuffs.perfectApBonus += 1; } },
                { id: "u5", name: "í”¼ì˜ ì—”ì§„", desc: "ì  ì²˜ì¹˜ ì‹œ ê³µê²©ë ¥ Ã—1.06 (ë¬´ì œí•œ) / í”¼ê²© í”¼í•´ x1.1", effect: p => { p.augBuffs.unlimitKillAtk = 0.06; p.augBuffs.takeDmgMult *= 1.1; } },
                { id: "u6", name: "ê²°íˆ¬ê°€", desc: "ì  1ë§ˆë¦¬ì¼ ë•Œ ê³µê²©ë ¥ Ã—1.35 / ê°•íƒ€ ì¶”ê°€ x1.15", effect: p => { p.augBuffs.soloAtk = 0.35; p.augBuffs.soloHeavy = 0.15; } },
                { id: "u7", name: "ì§‘í–‰ì¸ì˜ íŒê²°", desc: "ì  HP 40% ì´í•˜ ì‹œ Atk x1.25 / ê°•íƒ€ ì¶”ê°€ x1.2", effect: p => { p.augBuffs.executeAll = 0.25; p.augBuffs.heavyExecAll = 0.2; } },
                { id: "u8", name: "ì—°ì‡„ ë¶„ì‡„", desc: "ê°•íƒ€ ì—°ì† ì‚¬ìš©(ì—°ì† í„´) ì‹œ ê³µê²©ë ¥ Ã—1.50", effect: p => p.augBuffs.heavyChain = 0.5 },
                { id: "u9", name: "ì •ì ì˜ í˜¸í¡", desc: "í„´ ì‹œì‘ ì‹œ AP 5 ì´ìƒì´ë©´ ê³µê²©ë ¥ Ã—1.25", effect: p => p.augBuffs.highApBuff = 0.25 },
                { id: "u10", name: "ì™„ì „ë¬´ê²°", desc: "í¼í™íŠ¸ íŒ¨ë§ ë‹¹ Atk x1.08 (ìµœëŒ€ 3) / í”¼ê²© ì‹œ ì†Œë©¸", effect: p => p.augBuffs.perfStackBuff = 0.08 }
            ]
        };

        const ui = {
            hp: document.getElementById('p-hp'),
            atk: document.getElementById('p-atk'),
            def: document.getElementById('p-def'),
            ap: document.getElementById('p-ap'),
            turn: document.getElementById('turn-indicator'),
            msg: document.getElementById('message'),
            vignette: document.getElementById('vignette'),
            hitIcons: document.getElementById('hit-icons-container'),
            overlay: document.getElementById('start-overlay'),
            overlayAug: document.getElementById('augment-overlay'),
            overlayEvent: document.getElementById('event-overlay'),
            overlayGuide: document.getElementById('guide-overlay'),
            overlayGameOver: document.getElementById('game-over-overlay'), // NEW
            btnReroll: document.getElementById('btn-reroll'),
            btns: {
                atk: document.getElementById('btn-atk'),
                spin: document.getElementById('btn-spin'),
                heavy: document.getElementById('btn-heavy'),
                end: document.getElementById('btn-end')
            }
        };

        const CONFIG = {
            FPS: 60,
            PARRY_STANCE_DURATION: 21, // 0.35s (ìƒí–¥)
            PERFECT_WINDOW: 8,
            ATTACK_DURATION: 15,
            RETURN_DURATION: 20,
            K: 50 // ë°©ì–´ ìƒìˆ˜
        };

        const Player = {
            x: 150,
            y: 225,
            radius: 30,
            hp: 100,
            maxHp: 100,
            atk: 50,
            def: 0,
            ap: 0,
            color: "#4a9eff",
            parryTimer: 0,
            isParrying: false,
            actionsUsed: { atk: false, spin: false, heavy: false },
            augBuffs: {
                atk: 1.0, spin: 1.0, heavy: 1.0, parryAp: 0, startAp: 0,
                executeLow: 0, stackAtk: 0, heavySunder: 0, killAp: 0, perfectFocus: 0,
                stackAtkEpic: 0, heavyOverheat: 0, spinKillAp: 0, turnAtkPerf: 0,
                startTurnAtk: 0, killStackAtk: 0, heavyExecute: 0, lowApAtk: 1.0,
                inertiaSlice: 0, firstAtkMult: 0, heavyKillAp: 0, spinMultiTarget: 0,
                perfectApBonus: 0, unlimitKillAtk: 0, takeDmgMult: 1.0,
                soloAtk: 0, soloHeavy: 0, executeAll: 0, heavyExecAll: 0,
                heavyChain: 0, highApBuff: 0, perfStackBuff: 0
            },
            state: {
                killsThisTurn: 0, parryApGained: 0, isPrefGainedThisTurn: false,
                consecutiveTarget: null, consecutiveCount: 0,
                heavyUsedLastTurn: false, heavyHitThisTurn: false,
                perfFocusActive: false, perfParryThisTurn: false,
                killStacks: 0, unlimitKills: 0, firstAttackThisTurn: true,
                perfStacks: 0, multiAtkCount: 0, heavyLastTurn: false,
                atkUsedLastTurn: false
            },
            activeAugments: []
        };

        let rerollAvailable = true;
        let currentAugTier = "Common";
        let forcedTier = null;

        function showAugmentSelection(tier = null) {
            ui.overlayAug.style.display = "flex";
            rerollAvailable = true;
            ui.btnReroll.disabled = false;
            ui.btnReroll.innerText = "Reroll (1 Remaining)";

            if (tier) {
                currentAugTier = tier;
                forcedTier = tier;
            } else {
                forcedTier = null;
                const rand = Math.random();
                if (rand < 0.05) currentAugTier = "Unique";
                else if (rand < 0.30) currentAugTier = "Epic";
                else currentAugTier = "Common";
            }

            rollAugments();
        }

        function rollAugments() {
            const list = AUGMENT_DATA[currentAugTier];
            const shuffled = [...list].sort(() => 0.5 - Math.random()).slice(0, 3);
            const container = document.getElementById('augment-cards');
            container.innerHTML = "";
            shuffled.forEach(aug => {
                const card = document.createElement('div');
                card.className = `augment-card tier-${currentAugTier.toLowerCase()}`;
                card.innerHTML = `<h3>${aug.name}</h3><p style="color:#aaa; font-size:12px; margin:5px 0;">${currentAugTier}</p><p>${aug.desc}</p>`;
                card.onclick = () => selectAugment(aug);
                container.appendChild(card);
            });
        }

        function selectAugment(aug) {
            aug.effect(Player);
            Player.activeAugments.push(aug);
            ui.overlayAug.style.display = "none";

            if (currentRound === 3) {
                currentRound = 4;
                spawnWave(4);
            } else {
                spawnWave(currentRound);
            }
        }

        function rerollAugments() {
            if (!rerollAvailable) return;
            rerollAvailable = false;
            ui.btnReroll.disabled = true;
            ui.btnReroll.innerText = "Reroll (0 Remaining)";
            rollAugments();
        }

        class Monster {
            constructor(type, x, y, hp, atk, patterns) {
                this.name = type;
                this.homeX = x; this.homeY = y;
                this.x = x; this.y = y;
                // ë³´ìŠ¤(BOSS)ì¼ ê²½ìš° ë” í¬ê³  ìœ„í˜‘ì ì¸ ì—°ì¶œ
                if (type === "BOSS") {
                    this.radius = 60;
                    this.color = "#ff0000";
                } else {
                    this.radius = 25;
                    this.color = "#ff4a4a";
                }
                this.hp = hp; this.maxHp = hp; this.atk = atk;
                this.state = "IDLE"; this.timer = 0;
                this.patterns = patterns;
                this.currentPatternIdx = 0;
                this.currentPattern = patterns[0];
                this.patternStep = 0;
            }
            nextPattern() {
                this.currentPatternIdx = (this.currentPatternIdx + 1) % this.patterns.length;
                this.currentPattern = this.patterns[this.currentPatternIdx];
                this.patternStep = 0;
            }
        }

        const WAVE_DATA = {
            1: [
                { type: "Enemy 1", hp: 100, atk: 10, y: 150, patterns: ["NORMAL"] },
                { type: "Enemy 2", hp: 100, atk: 10, y: 350, patterns: ["NORMAL", "FAST"] }
            ],
            2: [
                { type: "Enemy A", hp: 80, atk: 9, y: 150, patterns: ["FAST"] },
                { type: "Enemy B", hp: 120, atk: 8, y: 350, patterns: ["NORMAL", "SLOW"] }
            ],
            3: [], // Event Round
            4: [
                { type: "Enemy A", hp: 85, atk: 9, y: 100, patterns: ["FAST"] },
                { type: "Enemy B", hp: 105, atk: 8, y: 250, patterns: ["NORMAL", "FAST"] },
                { type: "Enemy C", hp: 130, atk: 7, y: 400, patterns: ["NORMAL", "FAST", "SLOW"] }
            ],
            5: [
                { type: "Enemy A", hp: 70, atk: 10, y: 80, patterns: ["FAST"] },
                { type: "Enemy B", hp: 75, atk: 10, y: 180, patterns: ["NORMAL"] },
                { type: "Enemy C", hp: 110, atk: 9, y: 280, patterns: ["NORMAL", "FAST"] },
                { type: "Enemy D", hp: 140, atk: 8, y: 380, patterns: ["NORMAL", "FAST", "SLOW"] }
            ],
            6: [
                {
                    type: "BOSS", hp: 780, atk: 12, y: 225,
                    multiPatterns: [
                        ["NORMAL", "FAST", "SLOW"],
                        ["FAST", "NORMAL", "FAST", "SLOW"],
                        ["SLOW", "NORMAL", "FAST"]
                    ]
                }
            ]
        };

        const PATTERN_SPEEDS = {
            "FAST": 40,
            "NORMAL": 60,
            "SLOW": 90
        };

        let monsters = [];
        let currentTurn = "NONE";
        let currentMonsterIndex = 0;
        let isTargeting = false;
        let selectedSkill = null; // "atk", "spin", "heavy"
        let damageTexts = []; // {x, y, text, timer, color}
        let currentRound = 1;
        let isEndingTurnAutomatically = false;
        let gameStarted = false;
        let roundStartTimer = 0;
        let lastTimestamp = 0;

        // UI ìºì‹± í•„ë“œ
        const uiCache = {
            hp: -1, atk: -1, def: -1, ap: -1, turn: "",
            atkBtn: null, spinBtn: null, heavyBtn: null, endBtn: null
        };

        function toggleGuide(show) {
            ui.overlayGuide.style.display = show ? "flex" : "none";
        }

        function gameOver() {
            gameStarted = false;
            ui.overlayGameOver.style.display = "flex";
        }

        function retryGame() {
            // ì´ˆê¸°í™”
            Player.hp = 100;
            Player.ap = 0;
            Player.activeAugments = [];
            Player.augBuffs = {
                atk: 1.0, spin: 1.0, heavy: 1.0, parryAp: 0, startAp: 0,
                executeLow: 0, stackAtk: 0, heavySunder: 0, killAp: 0, perfectFocus: 0,
                stackAtkEpic: 0, heavyOverheat: 0, spinKillAp: 0, turnAtkPerf: 0,
                startTurnAtk: 0, killStackAtk: 0, heavyExecute: 0, lowApAtk: 1.0,
                inertiaSlice: 0, firstAtkMult: 0, heavyKillAp: 0, spinMultiTarget: 0,
                perfectApBonus: 0, unlimitKillAtk: 0, takeDmgMult: 1.0,
                soloAtk: 0, soloHeavy: 0, executeAll: 0, heavyExecAll: 0,
                heavyChain: 0, highApBuff: 0, perfStackBuff: 0
            };
            Player.state = {
                killsThisTurn: 0, parryApGained: 0, isPrefGainedThisTurn: false,
                consecutiveTarget: null, consecutiveCount: 0,
                heavyUsedLastTurn: false, heavyHitThisTurn: false,
                perfFocusActive: false, perfParryThisTurn: false,
                killStacks: 0, unlimitKills: 0, firstAttackThisTurn: true,
                perfStacks: 0, multiAtkCount: 0, heavyLastTurn: false,
                atkUsedLastTurn: false
            };
            currentRound = 1;
            ui.overlayGameOver.style.display = "none";
            startGame();
        }

        function startGame() {
            gameStarted = true;
            ui.overlay.style.display = "none";
            lastTimestamp = performance.now();
            spawnWave(currentRound);
            requestAnimationFrame(gameLoop);
        }

        function spawnWave(round) {
            if (round === 3) {
                showEventOverlay();
                return;
            }
            if (!WAVE_DATA[round]) {
                showFeedback("Game Clear!", "#FFD700");
                return;
            }

            monsters = WAVE_DATA[round].map(t => {
                let patterns = [];
                if (t.multiPatterns) {
                    patterns = t.multiPatterns.map(p => ({ hits: p.map(s => PATTERN_SPEEDS[s]) }));
                } else {
                    patterns = [{ hits: t.patterns.map(s => PATTERN_SPEEDS[s]) }];
                }

                return new Monster(t.type, 600, t.y, t.hp, t.atk, patterns);
            });
            currentMonsterIndex = 0;
            currentTurn = "MONSTER";
            roundStartTimer = 100; // ì•½ 1.6ì´ˆ ëŒ€ê¸°
            ui.turn.innerText = (round === 6) ? "Boss Round - Standby..." : `Round ${round} - Standby...`;
            showFeedback((round === 6) ? "Boss Appearance!" : `Round ${round} Start!`, (round === 6) ? "#ff4a4a" : "#fff");

            Player.ap += Player.augBuffs.startAp;
            Player.state.killsThisTurn = 0;
            Player.state.firstAttackThisTurn = true;
            updateHitIcons();
        }

        function showEventOverlay() {
            ui.overlayEvent.style.display = "flex";
        }

        function selectEventOption(option) {
            ui.overlayEvent.style.display = "none";
            if (option === 1) {
                showAugmentSelection("Common");
            } else {
                Player.hp = Math.min(Player.maxHp, Math.round(Player.hp + Player.maxHp * 0.35));
                showFeedback("Healed 35% HP", "#4f4");
                currentRound = 4;
                spawnWave(4);
            }
        }

        function winRound() {
            if (currentRound === 6) {
                showFeedback("VICTORY!", "#FFD700");
                gameStarted = false;
                // ìŠ¹ë¦¬ ì‹œ ë” ì´ìƒ ì§„í–‰ ì•ˆ í•¨
                return;
            }
            currentRound++;
            if (currentRound === 3) {
                showEventOverlay();
            } else {
                showAugmentSelection();
            }
        }

        function init() {
            window.addEventListener('mousedown', handleInput);
            ui.btns.atk.onclick = () => startSkill("atk");
            ui.btns.spin.onclick = () => executeSpinSlash(); // ì¦‰ì‹œ ì‹œì „
            ui.btns.heavy.onclick = () => startSkill("heavy");
            ui.btns.end.onclick = () => endPlayerTurn();
        }

        function startSkill(skill) {
            isTargeting = true;
            selectedSkill = skill;
            showFeedback("Select Target!", "#fff");
        }

        function handleInput(e) {
            if (!gameStarted) return;
            if (currentTurn === "PLAYER") {
                if (isTargeting) handleTargeting(e);
                return;
            }
            if (currentTurn === "MONSTER") {
                Player.parryTimer = CONFIG.PARRY_STANCE_DURATION;
                Player.isParrying = true;
            }
        }

        function handleTargeting(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            monsters.forEach((m) => {
                const dist = Math.sqrt((mx - m.x) ** 2 + (my - m.y) ** 2);
                if (dist < m.radius * 2 && m.hp > 0) {
                    if (selectedSkill === "atk") executeAttack(m);
                    else if (selectedSkill === "heavy") executeHeavyStrike(m);
                    isTargeting = false;
                    selectedSkill = null;
                }
            });
        }

        function executeAttack(target) {
            if (Player.ap < 2) return;
            Player.ap -= 2;
            dealDamage(Player.atk, target, "normal");
            Player.actionsUsed.atk = true;
            Player.state.multiAtkCount++;
            updateUI();
        }

        function executeHeavyStrike(target) {
            if (Player.ap < 5) return;
            Player.ap -= 5;
            dealDamage(Player.atk * 2, target, "heavy");
            Player.actionsUsed.heavy = true;
            updateUI();
        }

        function executeSpinSlash() {
            if (Player.ap < 3) return;
            const alive = monsters.filter(m => m.hp > 0);
            if (alive.length === 0) return;
            Player.ap -= 3;
            let mult = 1.2;
            if (alive.length >= 2) mult *= (1 + Player.augBuffs.spinMultiTarget);
            const totalDmg = Player.atk * mult;
            const dmgPer = totalDmg / alive.length;
            alive.forEach(m => dealDamage(dmgPer, m, "spin"));
            Player.actionsUsed.spin = true;
            showFeedback("SPIN SLASH!", "#4a4");
            updateUI();
        }

        function dealDamage(amount, target, type = "normal") {
            let mult = Player.augBuffs.atk;
            if (type === "spin") mult = Player.augBuffs.spin;
            if (type === "heavy") {
                mult = Player.augBuffs.heavy;
                // ì¦ê°•: ë‹¨ë‘ì˜ ê°
                if (target.hp / target.maxHp <= 0.3) mult *= (1 + Player.augBuffs.heavyExecute);
                // ì¦ê°•: ì§‘í–‰ì¸ì˜ íŒê²°
                if (target.hp / target.maxHp <= 0.4) mult *= (1 + Player.augBuffs.heavyExecAll);
            }

            // ê³µí†µ ì¦ê°• íš¨ê³¼
            if (target.hp / target.maxHp <= Player.augBuffs.executeLow) mult *= 1.15;
            if (target.hp / target.maxHp <= 0.4) mult *= (1 + Player.augBuffs.executeAll);

            // ì•½ì  íŒŒì•…/í•´ë¶€
            if (Player.state.consecutiveTarget === target) {
                if (Player.state.consecutiveCount >= 1) mult *= (1 + Player.augBuffs.stackAtk);
                mult *= (1 + Player.augBuffs.stackAtkEpic * Math.min(Player.state.consecutiveCount, 5));
            }

            // ì¡°ê±´ë¶€ ë²„í”„ë“¤
            if (Player.state.heavyUsedLastTurn && Player.state.firstAttackThisTurn) {
                mult *= (1 + Player.augBuffs.heavySunder);
                mult *= (1 + Player.augBuffs.heavyOverheat);
            }
            if (Player.state.atkUsedLastTurn && Player.state.firstAttackThisTurn) {
                mult *= (1 + Player.augBuffs.inertiaSlice); // Epic 9: ê´€ì„± ë² ê¸°
            }
            if (Player.state.perfParryThisTurn) mult *= (1 + Player.augBuffs.turnAtkPerf);
            if (Player.state.perfFocusActive) {
                mult *= (1 + Player.augBuffs.perfectFocus); // ì§‘ì¤‘ë ¥
                Player.state.perfFocusActive = false;
            }
            if (Player.state.unlimitKills > 0) mult *= (1 + Player.augBuffs.unlimitKillAtk * Player.state.unlimitKills);
            if (Player.state.killStacks > 0) mult *= (1 + Player.augBuffs.killStackAtk * Math.min(Player.state.killStacks, 10));

            //  Unique: ì •ì ì˜ í˜¸í¡, ê²°íˆ¬ê°€
            if (Player.state.highApAtkActive) mult *= (1 + Player.augBuffs.highApBuff);
            if (monsters.length === 1) {
                mult *= (1 + Player.augBuffs.soloAtk);
                if (type === "heavy") mult *= (1 + Player.augBuffs.soloHeavy);
            }
            if (Player.state.perfStacks > 0) mult *= (1 + Player.augBuffs.perfStackBuff * Player.state.perfStacks);
            if (Player.state.firstAttackThisTurn) {
                mult *= (1 + Player.augBuffs.firstAtkMult);
                if (type === "heavy") mult *= 1.08; // íŒŒê´´ì˜ ë§¥ë°•(ê°•íƒ€ì‹œ ì¶”ê°€) -> +0.1 ë³´ì •
            }
            // if (type === "normal" && Player.state.multiAtkCount >= 1) mult *= Player.augBuffs.multiAtkAtk; // This was removed in previous edits

            const finalDmg = Math.ceil(amount * mult);
            target.hp = Math.max(0, target.hp - finalDmg);
            addDamageText(target.x, target.y - 30, `-${finalDmg}`, "#ff4a4a");

            Player.state.firstAttackThisTurn = false;
            Player.state.consecutiveTarget = target;
            Player.state.consecutiveCount++;
            if (type === "heavy") Player.state.heavyHitThisTurn = true;

            if (target.hp <= 0) {
                target.state = "DONE";
                // ì¦ê°•: í”¼ì˜ íšŒìˆ˜, ì›ì‹¬ í­ë°œ
                if (Player.state.killsThisTurn < 2) Player.ap += Player.augBuffs.killAp;
                if (type === "spin" && Player.state.killsThisTurn < 2) Player.ap += Player.augBuffs.spinKillAp;
                if (type === "heavy" && Player.state.killsThisTurn < 1) Player.ap += Player.augBuffs.heavyKillAp;

                Player.state.killStacks++;
                Player.state.unlimitKills++;
                Player.state.killsThisTurn++;

                setTimeout(() => {
                    monsters = monsters.filter(m => m.hp > 0);
                    if (monsters.length === 0) {
                        winRound();
                    }
                }, 100);
            }
        }

        function endPlayerTurn() {
            if (currentTurn !== "PLAYER") return;
            currentTurn = "MONSTER";
            currentMonsterIndex = 0;
            // í„´ ì¢…ë£Œ ì‹œ ìƒíƒœ ê°±ì‹ 
            Player.state.heavyUsedLastTurn = Player.actionsUsed.heavy;
            Player.state.atkUsedLastTurn = Player.actionsUsed.atk; // Epic 9 ìœ„í•´ ì €ì¥
            Player.state.killsThisTurn = 0;
            isTargeting = false;
            selectedSkill = null;
            Player.actionsUsed = { atk: false, spin: false, heavy: false };
            isEndingTurnAutomatically = false;
            roundStartTimer = 50; // í„´ ì „í™˜ ëŒ€ê¸°
            monsters.forEach(m => {
                if (m.hp > 0) {
                    m.state = "IDLE";
                    m.patternStep = 0;
                    m.timer = 0;
                }
            });
            ui.turn.innerText = "Monster's Turn";
            updateHitIcons();
            updateUI();
        }

        function updateHitIcons() {
            ui.hitIcons.innerHTML = "";
            const m = monsters[currentMonsterIndex];
            if (!m || !m.patterns || currentTurn !== "MONSTER") return;

            const p = m.currentPattern; // Use currentPattern directly
            p.hits.forEach((h, i) => {
                const icon = document.createElement("div");
                icon.className = "hit-icon" + (i < m.patternStep ? " used" : "");
                ui.hitIcons.appendChild(icon);
            });
        }

        function showFeedback(text, color) {
            ui.msg.innerText = text;
            ui.msg.style.color = color;
            ui.msg.style.opacity = 1;
            setTimeout(() => ui.msg.style.opacity = 0, 800);
        }

        function addDamageText(x, y, text, color) {
            damageTexts.push({ x, y, text, color, timer: 60 });
        }

        function triggerVignette() {
            ui.vignette.classList.add('active');
            setTimeout(() => ui.vignette.classList.remove('active'), 300);
        }

        function update(dt) {
            if (!gameStarted) return;
            // íŒŒì›Œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            for (let i = damageTexts.length - 1; i >= 0; i--) {
                const dt_item = damageTexts[i];
                dt_item.y -= 0.5 * dt;
                dt_item.timer -= dt;
                if (dt_item.timer <= 0) damageTexts.splice(i, 1);
            }

            if (currentTurn === "PLAYER") {
                updateUI();
                checkAutoTurnEnd();
                return;
            }

            if (roundStartTimer > 0) {
                roundStartTimer -= dt;
                if (roundStartTimer <= 0) {
                    roundStartTimer = 0;
                    ui.turn.innerText = (currentRound === 6) ? "Boss Round" : "Monster's Turn";
                    updateHitIcons();
                    // ì¦ê°•: ì •ì ì˜ í˜¸í¡ (í„´ ì‹œì‘ ì‹œ ì²´í¬)
                    Player.state.highApAtkActive = (Player.ap >= 5);
                }
                updateUI();
                return;
            }

            // --- ëª¬ìŠ¤í„° í„´ ë¡œì§ ---
            if (Player.parryTimer > 0) Player.parryTimer -= dt;
            else { Player.parryTimer = 0; Player.isParrying = false; }

            const m = monsters[currentMonsterIndex];
            if (!m) { nextMonsterOrTurn(); return; }
            if (m.hp <= 0) { m.state = "DONE"; nextMonsterOrTurn(); return; }

            if (m.state === "IDLE") {
                m.timer += dt;
                if (m.timer > 60) {
                    m.currentPattern = m.patterns[m.currentPatternIdx];
                    m.state = "TELEGRAPH";
                    m.timer = 0;
                    m.startX = m.homeX; m.startY = m.homeY;
                    updateHitIcons();
                }
            } else if (m.state === "TELEGRAPH") {
                m.timer += dt;
                const waitFrames = m.currentPattern.hits[m.patternStep];
                const prepRatio = Math.min(m.timer / waitFrames, 1);
                m.x = m.homeX + Math.sin(prepRatio * Math.PI) * 20;
                if (m.timer >= waitFrames) { m.state = "ATTACK"; m.timer = 0; m.startX = m.x; m.startY = m.y; }
            } else if (m.state === "ATTACK") {
                m.timer += dt;
                let t = m.timer / CONFIG.ATTACK_DURATION;
                m.x = m.startX + (Player.x + Player.radius - m.startX) * (t * t);
                m.y = m.startY + (Player.y - m.startY) * (t * t);

                // íŒì • íƒ€ì´ë° (0~2í”„ë ˆì„ ì˜¤ì°¨ í—ˆìš©ì„ ìœ„í•´ ë²”ìœ„ ì²´í¬)
                if (m.timer >= CONFIG.ATTACK_DURATION - 2 && m.timer < CONFIG.ATTACK_DURATION && !m.hitTriggered) {
                    m.hitTriggered = true;
                    if (Player.isParrying) {
                        const elapsed = CONFIG.PARRY_STANCE_DURATION - Player.parryTimer;
                        if (elapsed <= CONFIG.PERFECT_WINDOW) {
                            showFeedback("PERFECT!", "#FFD700");
                            Player.ap += 2.0;
                            if (!Player.state.isPrefGainedThisTurn) {
                                Player.ap += Player.augBuffs.parryAp;
                                Player.state.isPrefGainedThisTurn = true;
                            }
                            if (Player.state.parryApGained < 2) {
                                Player.ap += Player.augBuffs.perfectApBonus;
                                Player.state.parryApGained++;
                            }
                            Player.state.perfFocusActive = true;
                            Player.state.perfParryThisTurn = true;
                            Player.state.perfStacks = Math.min(Player.state.perfStacks + 1, 3);
                        } else {
                            showFeedback("GOOD", "#00FF00");
                            Player.ap += 1.0;
                            if (!Player.state.isPrefGainedThisTurn) {
                                Player.ap += Player.augBuffs.parryAp;
                                Player.state.isPrefGainedThisTurn = true;
                            }
                        }
                    } else {
                        const finalDmg = Math.round(m.atk * (CONFIG.K / (CONFIG.K + Player.def)) * Player.augBuffs.takeDmgMult);
                        Player.hp = Math.max(0, Player.hp - finalDmg);
                        addDamageText(Player.x, Player.y - 40, `-${finalDmg}`, "#ff4a4a");
                        Player.state.perfStacks = 0;
                        triggerVignette();
                        if (Player.hp <= 0) gameOver();
                    }
                }

                if (m.timer >= CONFIG.ATTACK_DURATION) {
                    m.state = "RETURN"; m.returnStartX = m.x; m.returnStartY = m.y; m.timer = 0; m.hitTriggered = false;
                    m.patternStep++; updateHitIcons();
                }
            } else if (m.state === "RETURN") {
                m.timer += dt;
                const isLastHit = m.patternStep === m.currentPattern.hits.length;
                const duration = isLastHit ? CONFIG.RETURN_DURATION : 51;
                const targetX = isLastHit ? m.homeX : (m.homeX + m.returnStartX) / 2;
                const targetY = isLastHit ? m.homeY : (m.homeY + m.returnStartY) / 2;

                let t = m.timer / duration;
                m.x = m.returnStartX + (targetX - m.returnStartX) * (1 - Math.pow(1 - t, 2));
                m.y = m.returnStartY + (targetY - m.returnStartY) * (1 - Math.pow(1 - t, 2));

                if (m.timer >= duration) {
                    if (m.patternStep < m.currentPattern.hits.length) {
                        m.state = "ATTACK"; m.timer = 0; m.startX = m.x; m.startY = m.y;
                    } else {
                        if (currentRound === 6) m.nextPattern();
                        m.state = "DONE";
                        nextMonsterOrTurn();
                    }
                }
            }
            updateUI();
        }

        function checkAutoTurnEnd() {
            if (isEndingTurnAutomatically) return;

            // ì†Œìˆ˜ì  ì˜¤ì°¨ ë°©ì§€ë¥¼ ìœ„í•´ floor ì²˜ë¦¬ëœ AP ì‚¬ìš© ë° ì•½ê°„ì˜ ë§ˆì§„(0.1) ì¶”ê°€
            const fAp = Math.floor(Player.ap + 0.01);
            const canAtk = !Player.actionsUsed.atk && fAp >= 2;
            const canSpin = !Player.actionsUsed.spin && fAp >= 3;
            const canHeavy = !Player.actionsUsed.heavy && fAp >= 5;

            if (!canAtk && !canSpin && !canHeavy) {
                isEndingTurnAutomatically = true;
                setTimeout(endPlayerTurn, 800);
            }
        }

        function nextMonsterOrTurn() {
            if (currentMonsterIndex < monsters.length - 1) {
                currentMonsterIndex++;
                // ë‹¤ìŒ ëª¬ìŠ¤í„°ê°€ ì£½ì–´ìˆì„ ê²½ìš°ì— ëŒ€í•œ ì˜ˆì™¸ ì²˜ë¦¬
                if (monsters[currentMonsterIndex].hp <= 0) {
                    monsters[currentMonsterIndex].state = "DONE";
                    nextMonsterOrTurn();
                }
                updateHitIcons();
            } else {
                currentTurn = "PLAYER";
                ui.turn.innerText = "Player's Turn";
                ui.hitIcons.innerHTML = "";
            }
        }

        function updateUI() {
            if (uiCache.hp !== Player.hp) { ui.hp.innerText = Player.hp; uiCache.hp = Player.hp; }
            if (uiCache.atk !== Player.atk) { ui.atk.innerText = Player.atk; uiCache.atk = Player.atk; }
            if (uiCache.def !== Player.def) { ui.def.innerText = Player.def; uiCache.def = Player.def; }

            const fAp = Math.floor(Player.ap);
            if (uiCache.ap !== fAp) { ui.ap.innerText = fAp; uiCache.ap = fAp; }

            const atkD = currentTurn !== "PLAYER" || Player.ap < 2 || Player.actionsUsed.atk;
            const spinD = currentTurn !== "PLAYER" || Player.ap < 3 || Player.actionsUsed.spin;
            const heavyD = currentTurn !== "PLAYER" || Player.ap < 5 || Player.actionsUsed.heavy;
            const endD = currentTurn !== "PLAYER";

            if (uiCache.atkBtn !== atkD) { ui.btns.atk.disabled = atkD; uiCache.atkBtn = atkD; }
            if (uiCache.spinBtn !== spinD) { ui.btns.spin.disabled = spinD; uiCache.spinBtn = spinD; }
            if (uiCache.heavyBtn !== heavyD) { ui.btns.heavy.disabled = heavyD; uiCache.heavyBtn = heavyD; }
            if (uiCache.endBtn !== endD) { ui.btns.end.disabled = endD; uiCache.endBtn = endD; }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!gameStarted) return;

            monsters.forEach((m) => {
                let color = m.color; // ê¸°ë³¸ ë ˆë“œë¡œ ë³µêµ¬ (#ff4a4a)
                if (m.state === "TELEGRAPH") {
                    const waitFrames = m.currentPattern.hits[m.patternStep];
                    const alpha = m.timer / waitFrames;
                    color = `rgb(${255}, ${74 + 181 * alpha}, ${74 + 181 * alpha})`;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();

                // ëª¬ìŠ¤í„° HP ìˆ˜ì¹˜ í‘œì‹œ
                ctx.fillStyle = "#fff";
                ctx.font = "14px bold Inter";
                ctx.textAlign = "center";
                ctx.fillText(`HP ${Math.ceil(m.hp)}`, m.x, m.y + m.radius + 20);

                // íƒ€ê²ŸíŒ… í•˜ì´ë¼ì´íŠ¸
                if (isTargeting && m.hp > 0) {
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸
            damageTexts.forEach(dt => {
                ctx.fillStyle = dt.color;
                ctx.font = "bold 24px Inter";
                ctx.fillText(dt.text, dt.x, dt.y);
            });

            ctx.save();
            if (Player.isParrying) {
                // íŒ¨ë§ íƒœì„¸ ì‹œê° íš¨ê³¼ (ë…¸ë€ìƒ‰ ì˜¤ë¼)
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#FFD700";
                ctx.strokeStyle = "#FFD700";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(Player.x, Player.y, Player.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.fillStyle = Player.color;
            ctx.beginPath();
            ctx.arc(Player.x, Player.y, Player.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function gameLoop(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            let elapsed = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            // ë¸íƒ€ íƒ€ì„ ê³„ì‚° (60FPS ê¸°ì¤€ 1.0)
            // ë¸Œë¼ìš°ì € íƒ­ ì „í™˜ ë“±ìœ¼ë¡œ ì¸í•œ ê³¼ë„í•œ ì í”„ ë°©ì§€ (ìµœëŒ€ 100ms)
            // ì „ì²´ ê²Œì„ ì†ë„ë¥¼ 2ë°°ë¡œ ê°€ì†í•˜ì—¬ ë” ë°•ì§„ê° ë„˜ì¹˜ëŠ” ì•¡ì…˜ ì œê³µ
            let dt = (Math.min(elapsed, 100) / 16.66) * 2.0;

            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>
</body>

</html>